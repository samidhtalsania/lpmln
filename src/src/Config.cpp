/* Generated by re2c 0.16 on Mon Sep 12 15:24:56 2016 */
// 1 "Config.re"
#include "Config.h"
#include <vector>
#include <sys/stat.h> //To check if the file exists or not
#include <iostream>


Config::Config(int argc, char** argv){
	args = argv;
	if(argc < 2){
		showError(Error::NO_FILE,-1);
		return;
	}

	
	#define YYFILL(n)	{}
    
    

	for (int i = 0; i < argc; ++i)
	{
		const char* YYCTXMARKER;

		char* original = argv[i];

		#define YYCTYPE char
		#define YYFILL(n) {}    
		#define YYCURSOR original
		#define YYLIMIT original+sizeof(original)
		#define YYMARKER YYCURSOR
		#define YYCTXMARKER YYCURSOR 

		
// 36 "<stdout>"
{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy2;
	case '-':	goto yy6;
	case '.':
	case '/':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy7;
	default:	goto yy4;
	}
yy2:
	++YYCURSOR;
// 37 "Config.re"
	{ continue;}
// 115 "<stdout>"
yy4:
	++YYCURSOR;
yy5:
// 152 "Config.re"
	{
									Config::showError(Error::UNREGONIZED_OPTION,i);
									continue;
								}
// 124 "<stdout>"
yy6:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'A':	goto yy10;
	case 'M':	goto yy12;
	case 'T':	goto yy14;
	case 'a':	goto yy16;
	case 'd':	goto yy18;
	case 'h':	goto yy20;
	case 'm':	goto yy22;
	case 'o':	goto yy24;
	case 'p':	goto yy26;
	case 't':	goto yy28;
	case 'v':	goto yy30;
	default:	goto yy5;
	}
yy7:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '.':
	case '/':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy7;
	default:	goto yy9;
	}
yy9:
// 134 "Config.re"
	{
									if(i == 0){
										path = argv[i];
										continue;
									}
									else{
										struct stat buffer;
										if(stat(argv[i],&buffer) == 0){
											file = argv[i];
										}
										else{
											Config::showError(Error::INVALID_FILE,i);
										}
										continue;
									}

								}
// 232 "<stdout>"
yy10:
	++YYCURSOR;
// 62 "Config.re"
	{
									if(outputType == OutputType::OUTPUT_NONE)
										outputType = OutputType::OUTPUT_ASP;
									else
										Config::showError(Error::INVALID_OA,i);
									continue;	
								}
// 243 "<stdout>"
yy12:
	++YYCURSOR;
// 70 "Config.re"
	{
									if(outputType == OutputType::OUTPUT_NONE)
										outputType = OutputType::OUTPUT_ALCHEMY;
									else
										Config::showError(Error::INVALID_OM,i);
									continue;	
								}
// 254 "<stdout>"
yy14:
	++YYCURSOR;
// 78 "Config.re"
	{
									if(outputType == OutputType::OUTPUT_NONE)
										outputType = OutputType::OUTPUT_TUFFY;
									else
										Config::showError(Error::INVALID_OT,i);
									continue;	
								}
// 265 "<stdout>"
yy16:
	++YYCURSOR;
// 54 "Config.re"
	{
									if(parserType == ParserType::PARSER_NONE)
										parserType = ParserType::ASP;
									else
										Config::showError(Error::INVALID_A,i);
									continue;	
								}
// 276 "<stdout>"
yy18:
	++YYCURSOR;
// 96 "Config.re"
	{
									debug = true;
									continue;
								}
// 284 "<stdout>"
yy20:
	++YYCURSOR;
// 101 "Config.re"
	{
									Config::showHelp();
									help = true;
									return;
								}
// 293 "<stdout>"
yy22:
	++YYCURSOR;
// 45 "Config.re"
	{
									if(translation == Translation::Translation_None)
										translation = Translation::Alchemy;
									else
										Config::showError(Error::INVALID_M,i);
									continue;
										
								}
// 305 "<stdout>"
yy24:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':	goto yy32;
	case '1':	goto yy34;
	case '2':	goto yy36;
	default:	goto yy25;
	}
yy25:
	YYCURSOR = YYMARKER;
	goto yy5;
yy26:
	++YYCURSOR;
// 88 "Config.re"
	{
									if(parserType == ParserType::PARSER_NONE)
										parserType = ParserType::MVSM;
									else
										Config::showError(Error::INVALID_A,i);
									continue;
								}
// 327 "<stdout>"
yy28:
	++YYCURSOR;
// 38 "Config.re"
	{
									if(translation == Translation::Translation_None)
										translation = Translation::Tuffy;
									else
										Config::showError(Error::INVALID_T,i);
									continue;  	
								}
// 338 "<stdout>"
yy30:
	++YYCURSOR;
// 106 "Config.re"
	{
									Config::showVersion();
									help = true;
									return;
								}
// 347 "<stdout>"
yy32:
	++YYCURSOR;
// 112 "Config.re"
	{
									if(optimizationLevel == OptimizationLevel::ORPHAN_AUX)
										optimizationLevel = OptimizationLevel::OPTI_NONE;
									else
										Config::showError(Error::INAVLID_OPTIMIZATION_LEVEL,i);
									continue;
								}
// 358 "<stdout>"
yy34:
	++YYCURSOR;
// 120 "Config.re"
	{
									optimizationLevel = OptimizationLevel::ORPHAN_AUX;
									continue;
								}
// 366 "<stdout>"
yy36:
	++YYCURSOR;
// 125 "Config.re"
	{
									if(optimizationLevel == OptimizationLevel::ORPHAN_AUX)
										optimizationLevel = OptimizationLevel::ALL_CLAUSES_AUX;
									else
										Config::showError(Error::INAVLID_OPTIMIZATION_LEVEL,i);
									continue;
								}
// 377 "<stdout>"
}
// 156 "Config.re"

	}

	/*
		Check if user gave a file
	*/
	if(file.size() == 0){
		showError(Error::EXPECTED_FILE,-1);
	}

	/*
	User did not specify any translation. Default to alchemy.
	*/
	if(translation == Translation::Translation_None)
		translation = Translation::Alchemy;

	if(parserType == ParserType::PARSER_NONE)
		parserType = ParserType::FOL;
		
}


void Config::showError(Error e, int i){
	errors = true;
	switch(e){

		case Error::INVALID_T:
			std::cerr << "Invalid option -t \n"
						"use either of -a or -t not both \n";
			break;

		case Error::INVALID_M:
			std::cerr << "Invalid option -m \n"
						"use either of -m or -t not both \n";
			break;

		case Error::INVALID_FILE:
			std::cerr << "File could not be opened \n"
						"Check whether the file exists at location "<<file <<"\n";		
			break;

		case Error::INAVLID_OPTIMIZATION_LEVEL:
			std::cerr << "Use only one optimation level. Check help for details \n";
			break;


		case Error::NO_FILE:
			std::cerr << "No Input file provided.\n"
						"Use option -h for usage\n";
			break;

		case Error::EXPECTED_FILE:
			std::cerr << "Expected an Input file.\n";
			break;

		case Error::INVALID_A:
			std::cerr << "Invalid option -a \n";
			break;

		case Error::UNREGONIZED_OPTION:
			std::cerr << "Unrecognized option "<<args[i] <<"\n";
			break;

		case Error::INVALID_OA:
			std::cerr << "Invalid option -A \n";
			break;

		case Error::INVALID_OM:
			std::cerr << "Invalid option -M \n";
			break;

		case Error::INVALID_OT:
			std::cerr << "Invalid option -T \n";
			break;


		case Error::ERROR_NONE:				
		default:
			break;
	}
}

void Config::showHelp(){
	std::cout<<"LPMLN Version "<< VERSION << "\n"
				"Address Model: 64-bit \n"
				"\n"
				"Usage: lpmln [options] [file]"
				"\n"
				"Options:\n"
				"\n"
				"\t-m\tCompile for Alchemy\n"
				"\t-t\tCompile for Tuffy\n"
				"\t-a\tCompile with input in ASP like syntax\n"
				"\t-h\tShow this Message\n"
				"\t-v\tDisplay Version\n"
				"\n";

}

void Config::showVersion(){
	std::cout<<"LPMLN Version "<< VERSION <<"\n";
}

Config::~Config(){}

