/* Generated by re2c 0.16 on Mon Apr 24 21:42:33 2017 */
#line 1 "src/src/Config.re"
#include "Config.h"
#include <vector>
#include <sys/stat.h> //To check if the file exists or not
#include <iostream>


Config::Config(int argc, char** argv){
	args = argv;
	if(argc < 2){
		showError(Error::NO_FILE,-1);
		return;
	}

	
	#define YYFILL(n)	{}
    
    

	for (int i = 0; i < argc; ++i)
	{
		const char* YYCTXMARKER;

		char* original = argv[i];

		#define YYCTYPE char
		#define YYFILL(n) {}    
		#define YYCURSOR original
		#define YYLIMIT original+sizeof(original)
		#define YYMARKER YYCURSOR
		#define YYCTXMARKER YYCURSOR 

		
#line 36 "<stdout>"
{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy2;
	case '-':	goto yy6;
	case '.':
	case '/':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy7;
	default:	goto yy4;
	}
yy2:
	++YYCURSOR;
#line 37 "src/src/Config.re"
	{ continue;}
#line 115 "<stdout>"
yy4:
	++YYCURSOR;
yy5:
#line 175 "src/src/Config.re"
	{
									Config::showError(Error::UNREGONIZED_OPTION,i);
									continue;
								}
#line 124 "<stdout>"
yy6:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'A':	goto yy10;
	case 'M':	goto yy12;
	case 'R':	goto yy14;
	case 'T':	goto yy16;
	case 'a':	goto yy18;
	case 'd':	goto yy20;
	case 'f':	goto yy22;
	case 'h':	goto yy24;
	case 'm':	goto yy26;
	case 'o':	goto yy28;
	case 'p':	goto yy29;
	case 't':	goto yy31;
	case 'v':	goto yy33;
	default:	goto yy5;
	}
yy7:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '.':
	case '/':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy7;
	default:	goto yy9;
	}
yy9:
#line 157 "src/src/Config.re"
	{
									if(i == 0){
										path = argv[i];
										continue;
									}
									else{
										struct stat buffer;
										if(stat(argv[i],&buffer) == 0){
											file = argv[i];
										}
										else{
											Config::showError(Error::INVALID_FILE,i);
										}
										continue;
									}

								}
#line 234 "<stdout>"
yy10:
	++YYCURSOR;
#line 62 "src/src/Config.re"
	{
									if(outputType == OutputType::OUTPUT_NONE)
										outputType = OutputType::OUTPUT_ASP;
									else
										Config::showError(Error::INVALID_OA,i);
									continue;	
								}
#line 245 "<stdout>"
yy12:
	++YYCURSOR;
#line 70 "src/src/Config.re"
	{
									if(outputType == OutputType::OUTPUT_NONE)
										outputType = OutputType::OUTPUT_ALCHEMY;
									else
										Config::showError(Error::INVALID_OM,i);
									continue;	
								}
#line 256 "<stdout>"
yy14:
	++YYCURSOR;
#line 88 "src/src/Config.re"
	{
									if(outputType == OutputType::OUTPUT_NONE){
										outputType = OutputType::OUTPUT_ROCKIT;
										optimizationLevel = OptimizationLevel::ALL_CLAUSES_AUX;
									}
									else
										Config::showError(Error::INVALID_OT,i);
									continue;	
								}
#line 269 "<stdout>"
yy16:
	++YYCURSOR;
#line 78 "src/src/Config.re"
	{
									if(outputType == OutputType::OUTPUT_NONE){
										outputType = OutputType::OUTPUT_TUFFY;
										optimizationLevel = OptimizationLevel::ALL_CLAUSES_AUX;
									}
									else
										Config::showError(Error::INVALID_OT,i);
									continue;	
								}
#line 282 "<stdout>"
yy18:
	++YYCURSOR;
#line 54 "src/src/Config.re"
	{
									if(parserType == ParserType::PARSER_NONE)
										parserType = ParserType::ASP;
									else
										Config::showError(Error::INVALID_A,i);
									continue;	
								}
#line 293 "<stdout>"
yy20:
	++YYCURSOR;
#line 118 "src/src/Config.re"
	{
									debug = true;
									continue;
								}
#line 301 "<stdout>"
yy22:
	yych = *++YYCURSOR;
	switch (yych) {
	case '2':	goto yy35;
	default:	goto yy23;
	}
yy23:
	YYCURSOR = YYMARKER;
	goto yy5;
yy24:
	++YYCURSOR;
#line 123 "src/src/Config.re"
	{
									Config::showHelp();
									help = true;
									return;
								}
#line 319 "<stdout>"
yy26:
	++YYCURSOR;
#line 45 "src/src/Config.re"
	{
									if(translation == Translation::Translation_None)
										translation = Translation::Alchemy;
									else
										Config::showError(Error::INVALID_M,i);
									continue;
										
								}
#line 331 "<stdout>"
yy28:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':	goto yy36;
	case '1':	goto yy38;
	case '2':	goto yy40;
	default:	goto yy23;
	}
yy29:
	++YYCURSOR;
#line 100 "src/src/Config.re"
	{
									if(parserType == ParserType::PARSER_NONE)
										parserType = ParserType::MVSM;
									else
										Config::showError(Error::INVALID_A,i);
									continue;
								}
#line 350 "<stdout>"
yy31:
	++YYCURSOR;
#line 38 "src/src/Config.re"
	{
									if(translation == Translation::Translation_None)
										translation = Translation::Tuffy;
									else
										Config::showError(Error::INVALID_T,i);
									continue;  	
								}
#line 361 "<stdout>"
yy33:
	++YYCURSOR;
#line 128 "src/src/Config.re"
	{
									Config::showVersion();
									help = true;
									return;
								}
#line 370 "<stdout>"
yy35:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy42;
	default:	goto yy23;
	}
yy36:
	++YYCURSOR;
#line 134 "src/src/Config.re"
	{
									if(optimizationLevel == OptimizationLevel::ORPHAN_AUX)
										optimizationLevel = OptimizationLevel::OPTI_NONE;
									else
										Config::showError(Error::INAVLID_OPTIMIZATION_LEVEL,i);
									continue;
								}
#line 387 "<stdout>"
yy38:
	++YYCURSOR;
#line 142 "src/src/Config.re"
	{

									optimizationLevel = OptimizationLevel::ORPHAN_AUX;
									continue;
								}
#line 396 "<stdout>"
yy40:
	++YYCURSOR;
#line 148 "src/src/Config.re"
	{
									if(optimizationLevel == OptimizationLevel::ORPHAN_AUX)
										optimizationLevel = OptimizationLevel::ALL_CLAUSES_AUX;
									else
										Config::showError(Error::INAVLID_OPTIMIZATION_LEVEL,i);
									continue;
								}
#line 407 "<stdout>"
yy42:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'p':	goto yy43;
	default:	goto yy23;
	}
yy43:
	++YYCURSOR;
#line 108 "src/src/Config.re"
	{
									if(parserType == ParserType::PARSER_NONE)
										parserType = ParserType::F2LP;
									else
										Config::showError(Error::INVALID_A,i);
									continue;
		

								}
#line 426 "<stdout>"
}
#line 179 "src/src/Config.re"

	}

	/*
		Check if user gave a file
	*/
	if(file.size() == 0){
		showError(Error::EXPECTED_FILE,-1);
	}

	/*
	User did not specify any translation. Default to alchemy.
	*/
	if(translation == Translation::Translation_None)
		translation = Translation::Alchemy;

	if(parserType == ParserType::PARSER_NONE)
		parserType = ParserType::FOL;
		
}


void Config::showError(Error e, int i){
	errors = true;
	switch(e){

		case Error::INVALID_T:
			std::cerr << "Invalid option -t \n"
						"use either of -a or -t not both \n";
			break;

		case Error::INVALID_M:
			std::cerr << "Invalid option -m \n"
						"use either of -m or -t not both \n";
			break;

		case Error::INVALID_FILE:
			std::cerr << "File could not be opened \n"
						"Check whether the file exists at location "<<file <<"\n";		
			break;

		case Error::INAVLID_OPTIMIZATION_LEVEL:
			std::cerr << "Use only one optimation level. Check help for details \n";
			break;


		case Error::NO_FILE:
			std::cerr << "No Input file provided.\n"
						"Use option -h for usage\n";
			break;

		case Error::EXPECTED_FILE:
			std::cerr << "Expected an Input file.\n";
			break;

		case Error::INVALID_A:
			std::cerr << "Invalid option -a \n";
			break;

		case Error::UNREGONIZED_OPTION:
			std::cerr << "Unrecognized option "<<args[i] <<"\n";
			break;

		case Error::INVALID_OA:
			std::cerr << "Invalid option -A \n";
			break;

		case Error::INVALID_OM:
			std::cerr << "Invalid option -M \n";
			break;

		case Error::INVALID_OT:
			std::cerr << "Invalid option -T \n";
			break;


		case Error::ERROR_NONE:				
		default:
			break;
	}
}

void Config::showHelp(){
	std::cout<<"LPMLN Version "<< VERSION << "\n"
				"Address Model: 64-bit \n"
				"\n"
				"Usage: lpmln [options] [file]"
				"\n"
				"Options:\n"
				"\n"
				"\t-m\tCompile for Alchemy\n"
				"\t-t\tCompile for Tuffy\n"
				"\t-a\tCompile with input in ASP like syntax\n"
				"\t-h\tShow this Message\n"
				"\t-v\tDisplay Version\n"
				"\n";

}

void Config::showVersion(){
	std::cout<<"LPMLN Version "<< VERSION <<"\n";
}

Config::~Config(){}

